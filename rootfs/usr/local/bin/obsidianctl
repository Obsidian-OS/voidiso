#!/usr/bin/env python3
import argparse
import shutil
import shlex
import sys
import os
import subprocess
import re
import pwd
import tempfile

MIGRATION_LOG_FILE = "/etc/obsidianctl/migrations/applied.log"

def get_applied_migrations():
    if not os.path.exists(MIGRATION_LOG_FILE):
        return []
    with open(MIGRATION_LOG_FILE, "r") as f:
        return [line.strip() for line in f if line.strip()]

def record_applied_migration(migration_id):
    os.makedirs(os.path.dirname(MIGRATION_LOG_FILE), exist_ok=True)
    with open(MIGRATION_LOG_FILE, "a") as f:
        f.write(f"{migration_id}\n")

def remove_applied_migration(migration_id):
    if not os.path.exists(MIGRATION_LOG_FILE):
        return
    migrations = get_applied_migrations()
    with open(MIGRATION_LOG_FILE, "w") as f:
        for mid in migrations:
            if mid != str(migration_id):
                f.write(f"{mid}\n")

def is_grub_available():
    return shutil.which("grub-install") is not None or shutil.which("grub2-install") is not None

def is_grub_active():
    if os.path.exists("/boot/grub/grub.cfg"):
        return True
    try:
        efibootmgr_output = subprocess.check_output(["efibootmgr", "-v"], text=True)
        if "grub" in efibootmgr_output.lower():
            return True
    except (FileNotFoundError, subprocess.CalledProcessError):
        pass
    return False

def is_systemd_boot():
    try:
        output = subprocess.check_output(["bootctl", "status"], stderr=subprocess.DEVNULL, text=True)
        if "systemd-boot" in output or "Boot Loader:" in output:
            return True
        return False
    except (FileNotFoundError, subprocess.CalledProcessError):
        return False

def lordo(
    label, disk=None
):  # LORDO = LABEL On Root Disk Only, returns /dev/disk/by-uuid/UUID
    root_part = subprocess.check_output(
        ["findmnt", "-no", "SOURCE", "/"], text=True
    ).strip()
    if disk is None:
        disk_name = subprocess.check_output(
            ["lsblk", "-no", "PKNAME", root_part], text=True
        ).strip()
        disk = f"/dev/{disk_name}"
    parts = subprocess.check_output(
        ["lsblk", "-o", "NAME,LABEL,UUID", "-l", disk], text=True
    ).splitlines()
    for p in parts:
        fields = p.split(None, 2)  # NAME, LABEL, UUID
        if len(fields) < 3:
            continue
        name, lbl, uuid = fields
        if lbl.strip() == label:
            return f"/dev/disk/by-uuid/{uuid}"

    return None


def check_dependencies(commands):
    commands.extend(["curl", "tar", "mksquashfs", "unsquashfs"])
    for command in commands:
        if not shutil.which(command):
            print(f"Error: Required command '{command}' not found.", file=sys.stderr)
            sys.exit(1)


def checkroot():
    if os.geteuid() != 0:
        print("This script must be run as root.", file=sys.stderr)
        sys.exit(1)


def run_command(command, **kwargs):
    kwargs.setdefault("text", True)
    check = kwargs.pop("check", True)
    try:
        process = subprocess.run(
            command if isinstance(command, list) else shlex.split(command),
            check=check,
            **kwargs,
        )
        return process
    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {command}", file=sys.stderr)
        print(f"Exit Code: {e.returncode}", file=sys.stderr)
        if e.stdout:
            print(f"Stdout: {e.stdout}", file=sys.stderr)
        if e.stderr:
            print(f"Stderr: {e.stderr}", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print(f"Error: Command not found for: {command}", file=sys.stderr)
        sys.exit(1)

def _get_part_path(device, part_num):
    if "nvme" in device:
        return f"{device}p{part_num}"
    else:
        return f"{device}{part_num}"


def get_current_slot_systemd():
    try:
        bootctl_output = subprocess.check_output(["bootctl", "status"], text=True)
        match = re.search(
            r"^\s*id:\s+.*obsidian-([ab])\.conf", bootctl_output, re.MULTILINE
        )
        if match:
            return match.group(1)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    return "unknown"


#def get_current_slot():
#    if is_systemd_boot():
#        return get_current_slot_systemd()
#    elif is_grub_active():
#        try:
#            with open("/proc/cmdline", "r") as f:
#                cmdline = f.read()
#            root_match = re.search(r"root=(PARTUUID=)?([a-f0-9\-]+|/dev/[^\s]+)", cmdline)
#            if root_match:
#                root_identifier = root_match.group(2)
#                if "PARTUUID" in root_match.group(0):
#                    # If it's a PARTUUID, find the device path first
#                    device_path_output = subprocess.check_output(["blkid", "-t", f"PARTUUID={root_identifier}", "-o", "device"], text=True).strip()
#                    if device_path_output:
#                        root_device = device_path_output
#                    else:
#                        return "unknown"
#                else:
#                    root_device = root_identifier
#
#                # Get the label of the root device
#                label_output = subprocess.check_output(["lsblk", "-no", "LABEL", root_device], text=True).strip()
#                if "root_a" in label_output:
#                    return "a"
#                elif "root_b" in label_output:
#                    return "b"
#        except (subprocess.CalledProcessError, FileNotFoundError):
#            pass
#    return "unknown"
def get_current_slot():
    try:
        result = subprocess.run(
            ["findmnt", "-n", "-o", "SOURCE,UUID,PARTUUID,LABEL,PARTLABEL", "/"],
            capture_output=True, text=True, check=True
        )
        for item in result.stdout.split():
            if "_a" in item:
                return "a"
            elif "_b" in item:
                return "b"
    except subprocess.CalledProcessError:
        pass
    return "unknown"
def get_user_home_dir():
    if 'SUDO_USER' in os.environ:
        try:
            user = os.environ['SUDO_USER']
            return pwd.getpwnam(user).pw_dir
        except KeyError:
            pass
    return os.path.expanduser("~")

def get_primary_disk_device():
    root_part = run_command("findmnt -no SOURCE /", capture_output=True).stdout.strip()
    disk_name = run_command(f"lsblk -no PKNAME {root_part}", capture_output=True).stdout.strip()
    return f"/dev/{disk_name}"

def handle_status(args):
    logo = [
        "\033[0;36m *+++%\033[0;37m        ",
        "\033[0;36m****##%\033[0;37m       ",
        "\033[0;36m#***#\033[0;34m@ \033[0;34m@\033[0;37m      ",
        " \033[0;34m@     @  @\033[0;37m   ",
        "   \033[0;34m@    @  @\033[0;37m  ",
        "    \033[0;34m@  \033[0;35m#****#\033[0;37m ",
        "     \033[0;35m@ ######\033[0;37m ",
        "        \033[0;35m###%\033[0;37m  ",
    ]
    info = {}
    if is_systemd_boot():
        info["Bootloader"] = "systemd-boot"
    elif is_grub_active():
        info["Bootloader"] = "GRUB"
    else:
        info["Bootloader"] = "Unknown"
    info["Current Slot"] = get_current_slot()
    info["Kernel"] = run_command(
        "uname -r", capture_output=True, text=True
    ).stdout.strip()
    info["Uptime"] = (
        run_command("uptime -p", capture_output=True, text=True)
        .stdout.strip()
        .replace("up ", "")
    )
    try:
        with open("/etc/os-release") as f:
            os_release = dict(line.strip().split("=", 1) for line in f if "=" in line)
        info["OS"] = os_release.get("PRETTY_NAME", "GNU/Linux").strip('"')
    except FileNotFoundError:
        info["OS"] = "GNU/Linux"

    info["Hostname"] = run_command(
        "cat /etc/hostname", capture_output=True, text=True
    ).stdout.strip()
    cpu_info = run_command("lscpu", capture_output=True, text=True).stdout
    cpu_model_match = re.search(r"Model name:\s+(.*)", cpu_info)
    if cpu_model_match:
        info["CPU"] = cpu_model_match.group(1).strip()

    mem_info = run_command("free -h", capture_output=True, text=True).stdout
    mem_line = mem_info.split("\n")[1]
    mem_parts = mem_line.split()
    if len(mem_parts) >= 3:
        info["Memory"] = f"{mem_parts[2]} / {mem_parts[1]}"

    max_logo_width = max(len(line) for line in logo)
    for i in range(max(len(logo), len(info))):
        logo_line = logo[i] if i < len(logo) else " " * max_logo_width
        if i < len(info):
            key, value = list(info.items())[i]
            info_line = f"\033[1m{key}\033[0m: {value}"
        else:
            info_line = ""

        print(f"{logo_line}  {info_line}")
    print("\n\033[1mPartition Information:\033[0m")
    run_command("lsblk -o NAME,LABEL,SIZE,MOUNTPOINT")

def handle_dual_boot(args):
    checkroot()
    fstype="ext4"
    if args.use_f2fs:
        fstype="f2fs"
    device = args.device
    system_sfs = args.system_sfs

    if not os.path.exists(device):
        print(f"Error: Device '{device}' does not exist.", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)

    print(
        f"WARNING: This will install ObsidianOS on {device} alongside your existing OS."
    )
    print("Please ensure you have enough free space on the device.")
    confirm = input("Are you sure you want to proceed? (y/N): ")
    if confirm.lower() != "y":
        print("Installation aborted.")
        sys.exit(0)

    print("Partitioning device...")
    partition_table = f"""
label: gpt
,{args.esp_size},U,*
,{args.esp_size},U,*
,{args.rootfs_size},L,*
,{args.rootfs_size},L,*
,{args.etc_size},L,*
,{args.var_size},L,*
,,L,*
"""
    run_command(f"sfdisk --append {device}", input=partition_table, text=True)
    run_command("partprobe", check=False)
    print("Waiting for device partitions to settle...")
    run_command("udevadm settle")

    part_num = (
        int(
            run_command(
                f"bash -c \"lsblk -l -n -o MAJ:MIN,NAME | grep '{os.path.basename(device)}' | wc -l\"",
                capture_output=True,
                text=True,
            ).stdout.strip()
        )
        - 1
    )

    part1, part2, part3, part4, part5, part6, part7 = (
        _get_part_path(device, part_num - 6),
        _get_part_path(device, part_num - 5),
        _get_part_path(device, part_num - 4),
        _get_part_path(device, part_num - 3),
        _get_part_path(device, part_num - 2),
        _get_part_path(device, part_num - 1),
        _get_part_path(device, part_num),
    )

    print("Formatting partitions...")
    format_commands = [
        f"mkfs.fat -F32 -n ESP_A {part1}",
        f"mkfs.fat -F32 -n ESP_B {part2}",
        f"mkfs.{fstype} -F -L root_a {part3}",
        f"mkfs.{fstype} -F -L root_b {part4}",
        f"mkfs.{fstype} -F -L etc_ab {part5}",
        f"mkfs.{fstype} -F -L var_ab {part6}",
        f"mkfs.{fstype} -F -L home_ab {part7}",
    ]
    for cmd in format_commands:
        run_command(cmd)

    mount_dir = "/mnt/obsidian_install"
    run_command(f"mkdir -p {mount_dir}")
    print("Mounting root partition for slot 'a'...")
    run_command(f"mount /dev/disk/by-label/root_a {mount_dir}")
    print(f"Extracting system from {system_sfs} to slot 'a'...")
    run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
    print("Generating fstab for slot 'a'...")
    fstab_content_a = """
LABEL=root_a  /      {fstype}  defaults,noatime 0 1
LABEL=ESP_A     /boot  vfat  defaults,noatime 0 2
LABEL=etc_ab  /etc   {fstype}  defaults,noatime 0 2
LABEL=var_ab  /var   {fstype}  defaults,noatime 0 2
LABEL=home_ab /home  {fstype}  defaults,noatime 0 2
"""
    with open(f"{mount_dir}/etc/fstab", "w") as f:
        f.write(fstab_content_a.strip())

    print("Populating shared /etc, /var, and /home partitions...")
    for part_label in ["etc_ab", "var_ab", "home_ab"]:
        fs_dir = part_label.split("_")[0]
        tmp_mount_dir = f"/mnt/tmp_{fs_dir}"
        run_command(f"mkdir -p {tmp_mount_dir}")
        try:
            run_command(f"mount /dev/disk/by-label/{part_label} {tmp_mount_dir}")
            run_command(f"rsync -aK --delete {mount_dir}/{fs_dir}/ {tmp_mount_dir}/")
        finally:
            run_command(f"umount {tmp_mount_dir}", check=False)
            run_command(f"rmdir {tmp_mount_dir}", check=False)

    print("Populating ESP with boot files from system image...")
    esp_tmp_mount = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_A {esp_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
    finally:
        run_command(f"umount {esp_tmp_mount}", check=False)
        run_command(f"rmdir {esp_tmp_mount}", check=False)

    print("Populating ESP_B with boot files from system image...")
    esp_b_tmp_mount = "/mnt/obsidian_esp_b_tmp"
    run_command(f"mkdir -p {esp_b_tmp_mount}")
    try:
        run_command(f"mount /dev/disk/by-label/ESP_B {esp_b_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_b_tmp_mount}/")
    finally:
        run_command(f"umount {esp_b_tmp_mount}", check=False)
        run_command(f"rmdir {esp_b_tmp_mount}", check=False)

    print("Mounting shared partitions for potential chroot...")
    mount_commands = [
        f"mkdir -p {mount_dir}/boot",
        f"mkdir -p {mount_dir}/etc",
        f"mkdir -p {mount_dir}/var",
        f"mkdir -p {mount_dir}/home",
        f"mount /dev/disk/by-label/ESP_A {mount_dir}/boot",
        f"mount /dev/disk/by-label/etc_ab {mount_dir}/etc",
        f"mount /dev/disk/by-label/var_ab {mount_dir}/var",
        f"mount /dev/disk/by-label/home_ab {mount_dir}/home",
    ]
    for cmd in mount_commands:
        run_command(cmd)

    print("Copying support files to slot 'a'...")
    script_path = os.path.realpath(sys.argv[0])
    os_release_path = "/etc/os-release"
    obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
    if os.path.exists(f"{mount_dir}/obsidianctl-aur-installed"):
        print(
            "obsidianctl has been installed through the AUR. Skipping obsidianctl copy..."
        )
    else:
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
    if os.path.exists(os_release_path):
        run_command(f"cp {os_release_path} {mount_dir}/etc/os-release")
    else:
        print(
            f"Warning: os-release file not found at {os_release_path}. Skipping.",
            file=sys.stderr,
        )

    if os.path.exists("/usr/share/pixmaps/obsidianos.png"):
        run_command(f"mkdir -p {mount_dir}/usr/share/pixmaps/")
        run_command(f"cp /usr/share/pixmaps/obsidianos.png {mount_dir}/usr/share/pixmaps/obsidianos.png")
    else:
        print(
            f"Warning: ObsidianOS Logo file wasn't found. Skipping.",
            file=sys.stderr,
        )
    
    run_command(f"umount {mount_dir}/etc", check=False)

    autostart_service_content = """[Unit]
Description=Force start all enabled services before TTY login
DefaultDependencies=no
After=basic.target
Before=getty.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'systemctl list-unit-files --state=enabled | awk \"{print $1}\" | grep -E ".service$" | xargs -r systemctl start'

[Install]
WantedBy=getty.target
"""
    
    service_file_path = f"{mount_dir}/etc/systemd/system/obsidianos-autostart.service"
    run_command(f"mkdir -p {os.path.dirname(service_file_path)}")
    with open(service_file_path, "w") as f:
        f.write(autostart_service_content)

    
    run_command(f"systemctl enable obsidianos-autostart.service --root={mount_dir}")

    
    run_command(f"mount /dev/disk/by-label/etc_ab {mount_dir}/etc")

    print("\nSlot 'a' is now configured and mounted.")
    chroot_confirm = input(
        "Do you want to chroot into slot 'a' to make changes before copying it to slot B? (y/N): "
    )
    if chroot_confirm.lower() == "y":
        print(f"Entering chroot environment in {mount_dir}...")
        print(
            "Common tasks: passwd, ln -sf /usr/share/zoneinfo/Region/City /etc/localtime, useradd"
        )
        print("Type 'exit' or press Ctrl+D when you are finished.")
        run_command(f"arch-chroot {mount_dir}", check=False)
        print("Exited chroot.")

    print("Unmounting slot 'a' partitions before copy...")
    run_command(f"umount -R {mount_dir}")
    print("Copying system to slot 'b'...")
    source_mount_point = "/mnt/obsidian_source_a"
    target_mount_point = "/mnt/obsidian_target_b"
    run_command(f"mkdir -p {source_mount_point} {target_mount_point}")
    try:
        run_command(f"mount {part3} {source_mount_point}")
        run_command(f"mount {part4} {target_mount_point}")
        run_command(f"rsync -aHAX --inplace --delete --info=progress2 {source_mount_point}/ {target_mount_point}/")
    finally:
        run_command(f"umount {source_mount_point}", check=False)
        run_command(f"umount {target_mount_point}", check=False)
        run_command(f"rm -r {source_mount_point} {target_mount_point}", check=False)

    run_command(f"e2label {part4} root_b")
    print("Correcting fstab for slot 'b'...")
    mount_b_dir = "/mnt/obsidian_install_b"
    run_command(f"mkdir -p {mount_b_dir}")
    try:
        run_command(f"mount {part4} {mount_b_dir}")
        fstab_b_path = f"{mount_b_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_b_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_b_path)}")
        fstab_content_b = fstab_content_a.replace(
            "LABEL=root_a", "LABEL=root_b"
        ).replace("LABEL=ESP_A", "LABEL=ESP_B")
        with open(fstab_b_path, "w") as f:
            f.write(fstab_content_b)
    finally:
        run_command(f"umount {mount_b_dir}", check=False)
        run_command(f"rm -r {mount_b_dir}", check=False)

    if not args.use_systemdboot:
        mount_dir="/mnt/obsidianos-install-grub"
        print("Installing GRUB to ESP_A...")
        run_command(f"mkdir -p {mount_dir}")
        mount_commands = [
            f"mount {lordo('root_a', device)} {mount_dir}/",
            f"mount {lordo('ESP_A', device)} {mount_dir}/boot",
            f"mount {lordo('etc_ab', device)} {mount_dir}/etc",
            f"mount {lordo('var_ab', device)} {mount_dir}/var",
            f"mount {lordo('home_ab', device)} {mount_dir}/home",
        ]
        for cmd in mount_commands:
            run_command(cmd)
        if args.use_grub2:
            run_command(f"arch-chroot {mount_dir} grub2-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} sed -i 's|^#*GRUB_DISABLE_OS_PROBER=.*|GRUB_DISABLE_OS_PROBER=false|' /etc/default/grub")
            run_command(f"arch-chroot {mount_dir} grub2-mkconfig -o /boot/grub/grub.cfg")
        else:
            run_command(f"arch-chroot {mount_dir} grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} sed -i 's|^#*GRUB_DISABLE_OS_PROBER=.*|GRUB_DISABLE_OS_PROBER=false|' /etc/default/grub")
            run_command(f"arch-chroot {mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
        run_command(f"umount -R {mount_dir}")
        mount_commands = [
            f"mount {lordo('root_b', device)} {mount_dir}/",
            f"mount {lordo('ESP_B', device)} {mount_dir}/boot",
            f"mount {lordo('etc_ab', device)} {mount_dir}/etc",
            f"mount {lordo('var_ab', device)} {mount_dir}/var",
            f"mount {lordo('home_ab', device)} {mount_dir}/home",
        ]
        for cmd in mount_commands:
            run_command(cmd)
        if args.use_grub2:
            run_command(f"arch-chroot {mount_dir} grub2-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} grub2-mkconfig -o /boot/grub/grub.cfg")
        else:
            run_command(f"arch-chroot {mount_dir} grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
        run_command(f"umount -R {mount_dir}")
    else:
        print("Installing systemd-boot to ESP_A...")
        esp_a_mount_dir = "/mnt/obsidian_esp_a"
        run_command(f"mkdir -p {esp_a_mount_dir}")
        try:
            run_command(f"mount {part1} {esp_a_mount_dir}")
            run_command(
                f'bootctl --esp-path={esp_a_mount_dir} --efi-boot-option-description="ObsidianOS (Slot A)" install'
            )
        finally:
            run_command(f"umount {esp_a_mount_dir}", check=False)
            run_command(f"rm -r {esp_a_mount_dir}", check=False)

        print("Installing systemd-boot to ESP_B...")
        esp_b_mount_dir = "/mnt/obsidian_esp_b"
        run_command(f"mkdir -p {esp_b_mount_dir}")
        try:
            run_command(f"mount {part2} {esp_b_mount_dir}")
            run_command(
                f'bootctl --esp-path={esp_b_mount_dir} --efi-boot-option-description="ObsidianOS (Slot B)" install'
            )
        finally:
            run_command(f"umount {esp_b_mount_dir}", check=False)
            run_command(f"rm -r {esp_b_mount_dir}", check=False)

        root_a_partuuid = run_command(
            f"blkid -s PARTUUID -o value {part3}", capture_output=True, text=True
        ).stdout.strip()
        root_b_partuuid = run_command(
            f"blkid -s PARTUUID -o value {part4}", capture_output=True, text=True
        ).stdout.strip()
        if not root_a_partuuid or not root_b_partuuid:
            print(
                "Could not determine PARTUUIDs for root partitions. Cannot create boot entries.",
                file=sys.stderr,
            )
            sys.exit(1)

        loader_conf = """
timeout 3
default obsidian-a.conf
"""
        entry_a_conf = f"""
title ObsidianOS (Slot A)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_a_partuuid} rw
"""
        entry_b_conf = f"""
title ObsidianOS (Slot B)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_b_partuuid} rw
"""

        esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
        run_command(f"mkdir -p {esp_a_config_mount_dir}")
        try:
            run_command(f"mount {part1} {esp_a_config_mount_dir}")
            run_command(f"mkdir -p {esp_a_config_mount_dir}/loader/entries")
            with open(f"{esp_a_config_mount_dir}/loader/loader.conf", "w") as f:
                f.write(loader_conf)
            with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
                f.write(entry_a_conf)
            with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
                f.write(entry_b_conf)
        finally:
            run_command(f"umount {esp_a_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_a_config_mount_dir}", check=False)

        print("Writing boot configuration to ESP_B...")
        esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
        run_command(f"mkdir -p {esp_b_config_mount_dir}")
        try:
            run_command(f"mount {part2} {esp_b_config_mount_dir}")
            run_command(f"mkdir -p {esp_b_config_mount_dir}/loader/entries")
            with open(f"{esp_b_config_mount_dir}/loader/loader.conf", "w") as f:
                f.write(loader_conf)
            with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
                f.write(entry_a_conf)
            with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
                f.write(entry_b_conf)
        finally:
            run_command(f"umount {esp_b_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_b_config_mount_dir}", check=False)

        print("Detecting other operating systems...")
        esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
        esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
        run_command(f"mkdir -p {esp_a_config_mount_dir}")
        run_command(f"mkdir -p {esp_b_config_mount_dir}")
        try:
            run_command(f"mount {part1} {esp_a_config_mount_dir}")
            run_command(f"mount {part2} {esp_b_config_mount_dir}")
            os_prober_output = run_command(
                "os-prober", capture_output=True, text=True
            ).stdout.strip()
            if os_prober_output:
                print("Found other operating systems:")
                print(os_prober_output)
                esp_a_entries_path = f"{esp_a_config_mount_dir}/loader/entries"
                esp_b_entries_path = f"{esp_b_config_mount_dir}/loader/entries"
                for i, line in enumerate(os_prober_output.splitlines()):
                    parts = line.split(":")
                    if len(parts) >= 3:
                        device_path = parts[0]
                        os_name = parts[1]
                        entry_filename = f"50-other-os-{i}.conf"
                        entry_content = f"""title {os_name}
                        efi {device_path}
                        """                        
                        with open(f"{esp_a_entries_path}/{entry_filename}", "w") as f:
                            f.write(entry_content)
                        with open(f"{esp_b_entries_path}/{entry_filename}", "w") as f:
                            f.write(entry_content)
                        print(f"Created boot entry for {os_name}")

            else:
                print("No other operating systems found.")
        except Exception as e:
            print(f"Error running os-prober: {e}")
            print("Please make sure os-prober is installed.")
        finally:
            run_command(f"umount {esp_a_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_a_config_mount_dir}", check=False)
            run_command(f"umount {esp_b_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_b_config_mount_dir}", check=False)

        run_command(f"rm -r {mount_dir}", check=False)
        print("\nInstallation complete!")
        print("Default boot order will attempt Slot A, then Slot B.")
        print("Reboot your system to apply changes.")

def handle_mkobsidiansfs(args):
    if shutil.which("mkobsidiansfs"):
        os.system(f"mkobsidiansfs {args.system_sfs} system.sfs")
    else:
        if shutil.which("git"):
            os.system(
                f"git clone https://github.com/Obsidian-OS/mkobsidiansfs/ /tmp/mkobsidiansfs;chmod u+x /tmp/mkobsidiansfs/mkobsidiansfs;/tmp/mkobsidiansfs/mkobsidiansfs {args.system_sfs} tmp_system.sfs"
            )
        else:
            print(
                "No git or mkobsidiansfs found. Please install one of these to directly pass in an .mkobsfs."
            )
            sys.exit(1)
    args.system_sfs = "tmp_system.sfs"
    handle_install(args)
    os.remove("tmp_system.sfs")


def handle_install(args):
    checkroot()
    device = args.device
    system_sfs = args.system_sfs or "/etc/system.sfs"
    _, ext = os.path.splitext(system_sfs)
    if ext == ".mkobsfs":
        handle_mkobsidiansfs(args)
        sys.exit()
    if args.dual_boot:
        handle_dual_boot(args)
        return

    if not os.path.exists(device):
        print(f"Error: Device '{device}' does not exist.", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)

    print(f"WARNING: This will destroy all data on {device}.")
    confirm = input("Are you sure you want to proceed? (y/N): ")
    if confirm.lower() != "y":
        print("Installation aborted.")
        sys.exit(0)
    fstype="ext4"
    if args.use_f2fs:
        print(f"WARNING: F2FS is a filesystem ONLY for fragile NAND.")
        confirm = input("This is only for advanced users. Are you sure you want to proceed? (y/N): ")
        if confirm.lower() != "y":
            fstype="ext4"
        else:
            fstype="f2fs"
    print("Partitioning device...")
    partition_table = f"""
label: gpt
,{args.esp_size},U,*
,{args.esp_size},U,*
,{args.rootfs_size},L,*
,{args.rootfs_size},L,*
,{args.etc_size},L,*
,{args.var_size},L,*
,,L,*
"""
    run_command(f"sfdisk {device}", input=partition_table, text=True)
    run_command("partprobe", check=False)
    print("Waiting for device partitions to settle...")
    run_command("udevadm settle")
    part1, part2, part3, part4, part5, part6, part7 = (
        _get_part_path(device, 1),
        _get_part_path(device, 2),
        _get_part_path(device, 3),
        _get_part_path(device, 4),
        _get_part_path(device, 5),
        _get_part_path(device, 6),
        _get_part_path(device, 7),
    )

    print("Formatting partitions...")
    format_commands = [
        f"mkfs.fat    -F32 -n ESP_A   {part1}",
        f"mkfs.fat    -F32 -n ESP_B   {part2}",
        f"mkfs.{fstype} -F -L root_a  {part3}",
        f"mkfs.{fstype} -F -L root_b  {part4}",
        f"mkfs.{fstype} -F -L etc_ab  {part5}",
        f"mkfs.{fstype} -F -L var_ab  {part6}",
        f"mkfs.{fstype} -F -L home_ab {part7}",
    ]
    for cmd in format_commands:
        run_command(cmd)

    mount_dir = "/mnt/obsidian_install"
    run_command(f"mkdir -p {mount_dir}")
    print("Mounting root partition for slot 'a'...")
    run_command(f"mount {lordo('root_a', device)} {mount_dir}")
    print(f"Extracting system from {system_sfs} to slot 'a'...")
    run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
    print("Generating fstab for slot 'a'...")
    fstab_content_a = f"""
{lordo('root_a', device)}  /      {fstype}  defaults,noatime 0 1
{lordo('ESP_A', device)}     /boot  vfat  defaults,noatime 0 2
{lordo('etc_ab', device)}  /etc   {fstype}  defaults,noatime 0 2
{lordo('var_ab', device)}  /var   {fstype}  defaults,noatime 0 2
{lordo('home_ab', device)} /home  {fstype}  defaults,noatime 0 2
"""
    with open(f"{mount_dir}/etc/fstab", "w") as f:
        f.write(fstab_content_a.strip())

    print("Populating shared /etc, /var, and /home partitions...")
    for part_label in ["etc_ab", "var_ab", "home_ab"]:
        fs_dir = part_label.split("_")[0]
        tmp_mount_dir = f"/mnt/tmp_{fs_dir}"
        run_command(f"mkdir -p {tmp_mount_dir}")
        try:
            run_command(f"mount {lordo(part_label, device)} {tmp_mount_dir}")
            run_command(f"rsync -aK --delete {mount_dir}/{fs_dir}/ {tmp_mount_dir}/")
        finally:
            run_command(f"umount {tmp_mount_dir}", check=False)
            run_command(f"rmdir {tmp_mount_dir}", check=False)

    print("Populating ESP with boot files from system image...")
    esp_tmp_mount = "/mnt/obsidian_esp_tmp"
    run_command(f"mkdir -p {esp_tmp_mount}")
    try:
        run_command(f"mount {lordo('ESP_A', device)} {esp_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
    finally:
        run_command(f"umount {esp_tmp_mount}", check=False)
        run_command(f"rmdir {esp_tmp_mount}", check=False)

    print("Populating ESP_B with boot files from system image...")
    esp_b_tmp_mount = "/mnt/obsidian_esp_b_tmp"
    run_command(f"mkdir -p {esp_b_tmp_mount}")
    try:
        run_command(f"mount {lordo('ESP_B', device)} {esp_b_tmp_mount}")
        run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_b_tmp_mount}/")
    finally:
        run_command(f"umount {esp_b_tmp_mount}", check=False)
        run_command(f"rmdir {esp_b_tmp_mount}", check=False)

    print("Mounting shared partitions for potential chroot...")
    mount_commands = [
        f"mkdir -p {mount_dir}/boot",
        f"mkdir -p {mount_dir}/etc",
        f"mkdir -p {mount_dir}/var",
        f"mkdir -p {mount_dir}/home",
        f"mount {lordo('ESP_A', device)} {mount_dir}/boot",
        f"mount {lordo('etc_ab', device)} {mount_dir}/etc",
        f"mount {lordo('var_ab', device)} {mount_dir}/var",
        f"mount {lordo('home_ab', device)} {mount_dir}/home",
    ]
    for cmd in mount_commands:
        run_command(cmd)

    print("Copying support files to slot 'a'...")
    script_path = os.path.realpath(sys.argv[0])
    os_release_path = "/etc/os-release"
    obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
    if os.path.exists(f"{mount_dir}/obsidianctl-aur-installed"):
        print(
            "obsidianctl has been installed through the AUR. Skipping obsidianctl copy..."
        )
    else:
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
    if os.path.exists(os_release_path):
        run_command(f"cp {os_release_path} {mount_dir}/etc/os-release")
    else:
        print(
            f"Warning: os-release file not found at {os_release_path}. Skipping.",
            file=sys.stderr,
        )

    if os.path.exists("/usr/share/pixmaps/obsidianos.png"):
        run_command(f"mkdir -p {mount_dir}/usr/share/pixmaps/")
        run_command(
            f"cp /usr/share/pixmaps/obsidianos.png {mount_dir}/usr/share/pixmaps/obsidianos.png"
        )
    else:
        print(
            f"Warning: ObsidianOS Logo file wasn't found. Skipping.",
            file=sys.stderr,
        ) 
    run_command(f"umount {mount_dir}/etc", check=False)

    autostart_service_content = """[Unit]
Description=Force start all enabled services before TTY login
DefaultDependencies=no
After=basic.target
Before=getty.target

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'systemctl list-unit-files --state=enabled | awk \"{print $1}\" | grep -E ".service$" | xargs -r systemctl start'

[Install]
WantedBy=getty.target
"""
    service_file_path = f"{mount_dir}/etc/systemd/system/obsidianos-autostart.service"
    run_command(f"mkdir -p {os.path.dirname(service_file_path)}")
    with open(service_file_path, "w") as f:
        f.write(autostart_service_content)
    run_command(f"systemctl enable obsidianos-autostart.service --root={mount_dir}")
    run_command(f"mount {lordo('etc_ab', device)} {mount_dir}/etc")
    print("\nSlot 'a' is now configured and mounted.")
    chroot_confirm = input(
        "Do you want to chroot into slot 'a' to make changes before copying it to slot B? (y/N): "
    )
    if chroot_confirm.lower() == "y":
        print(f"Entering chroot environment in {mount_dir}...")
        print(
            "Common tasks: passwd, ln -sf /usr/share/zoneinfo/Region/City /etc/localtime, useradd"
        )
        print("Type 'exit' or press Ctrl+D when you are finished.")
        run_command(f"arch-chroot {mount_dir}", check=False)
        print("Exited chroot.")

    print("Unmounting slot 'a' partitions before copy...")
    run_command(f"umount -R {mount_dir}")
    print("Copying system to slot 'b'...")
    source_mount_point = "/mnt/obsidian_source_a"
    target_mount_point = "/mnt/obsidian_target_b"
    run_command(f"mkdir -p {source_mount_point} {target_mount_point}")
    try:
        run_command(f"mount {part3} {source_mount_point}")
        run_command(f"mount {part4} {target_mount_point}")
        run_command(
            f"rsync -aHAX --inplace --delete --info=progress2 {source_mount_point}/ {target_mount_point}/"
        )
    finally:
        run_command(f"umount {source_mount_point}", check=False)
        run_command(f"umount {target_mount_point}", check=False)
        run_command(f"rm -r {source_mount_point} {target_mount_point}", check=False)
    run_command(f"e2label {part4} root_b")
    print("Correcting fstab for slot 'b'...")
    mount_b_dir = "/mnt/obsidian_install_b"
    run_command(f"mkdir -p {mount_b_dir}")
    try:
        run_command(f"mount {part4} {mount_b_dir}")
        fstab_b_path = f"{mount_b_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_b_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_b_path)}")
        with open(fstab_b_path, "w") as f:
            f.write(f"""
{lordo('root_b', device)}  /      {fstype}  defaults,noatime 0 1
{lordo('ESP_B', device)}     /boot  vfat  defaults,noatime 0 2
{lordo('etc_ab', device)}  /etc   {fstype}  defaults,noatime 0 2
{lordo('var_ab', device)}  /var   {fstype}  defaults,noatime 0 2
{lordo('home_ab', device)} /home  {fstype}  defaults,noatime 0 2
""")
    finally:
        run_command(f"umount {mount_b_dir}", check=False)
        run_command(f"rm -r {mount_b_dir}", check=False)

    if not args.use_systemdboot:
        mount_dir="/mnt/obsidianos-install-grub"
        print("Installing GRUB to ESP_A...")
        run_command(f"mkdir -p {mount_dir}")
        mount_commands = [
            f"mount {lordo('root_a', device)} {mount_dir}/",
            f"mount {lordo('ESP_A', device)} {mount_dir}/boot",
            f"mount {lordo('etc_ab', device)} {mount_dir}/etc",
            f"mount {lordo('var_ab', device)} {mount_dir}/var",
            f"mount {lordo('home_ab', device)} {mount_dir}/home",
        ]
        for cmd in mount_commands:
            run_command(cmd)
        if args.use_grub2:
            run_command(f"arch-chroot {mount_dir} grub2-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} sed -i 's|^#*GRUB_DISABLE_OS_PROBER=.*|GRUB_DISABLE_OS_PROBER=false|' /etc/default/grub")
            run_command(f"arch-chroot {mount_dir} grub2-mkconfig -o /boot/grub/grub.cfg")
        else:
            run_command(f"arch-chroot {mount_dir} grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} sed -i 's|^#*GRUB_DISABLE_OS_PROBER=.*|GRUB_DISABLE_OS_PROBER=false|' /etc/default/grub")
            run_command(f"arch-chroot {mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
        run_command(f"umount -R {mount_dir}")
        mount_commands = [
            f"mount {lordo('root_b', device)} {mount_dir}/",
            f"mount {lordo('ESP_B', device)} {mount_dir}/boot",
            f"mount {lordo('etc_ab', device)} {mount_dir}/etc",
            f"mount {lordo('var_ab', device)} {mount_dir}/var",
            f"mount {lordo('home_ab', device)} {mount_dir}/home",
        ]
        for cmd in mount_commands:
            run_command(cmd)
        if args.use_grub2:
            run_command(f"arch-chroot {mount_dir} grub2-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} grub2-mkconfig -o /boot/grub/grub.cfg")
        else:
            run_command(f"arch-chroot {mount_dir} grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ObsidianOSslotA")
            run_command(f"arch-chroot {mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
        run_command(f"umount -R {mount_dir}")
    else:
        print("Installing systemd-boot to ESP_A...")
        esp_a_mount_dir = "/mnt/obsidian_esp_a"
        run_command(f"mkdir -p {esp_a_mount_dir}")
        try:
            run_command(f"mount {part1} {esp_a_mount_dir}")
            run_command(
                f'bootctl --esp-path={esp_a_mount_dir} --efi-boot-option-description="ObsidianOS (Slot A)" install'
            )
        finally:
            run_command(f"umount {esp_a_mount_dir}", check=False)
            run_command(f"rm -r {esp_a_mount_dir}", check=False)

        print("Installing systemd-boot to ESP_B...")
        esp_b_mount_dir = "/mnt/obsidian_esp_b"
        run_command(f"mkdir -p {esp_b_mount_dir}")
        try:
            run_command(f"mount {part2} {esp_b_mount_dir}")
            run_command(f'bootctl --esp-path={esp_b_mount_dir} --efi-boot-option-description="ObsidianOS (Slot B)" install')
        finally:
            run_command(f"umount {esp_b_mount_dir}", check=False)
            run_command(f"rm -r {esp_b_mount_dir}", check=False)

        root_a_partuuid = run_command(
            f"blkid -s PARTUUID -o value {part3}", capture_output=True, text=True
        ).stdout.strip()
        root_b_partuuid = run_command(
            f"blkid -s PARTUUID -o value {part4}", capture_output=True, text=True
        ).stdout.strip()
        if not root_a_partuuid or not root_b_partuuid:
            print(
                "Could not determine PARTUUIDs for root partitions. Cannot create boot entries.",
                file=sys.stderr,
            )
            sys.exit(1)

        loader_conf = """
timeout 0
default obsidian-a.conf
"""
        entry_a_conf = f"""
title ObsidianOS (Slot A)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_a_partuuid} rw
"""
        entry_b_conf = f"""
title ObsidianOS (Slot B)
linux /vmlinuz-linux
initrd /initramfs-linux.img
options root=PARTUUID={root_b_partuuid} rw
"""

        esp_a_config_mount_dir = "/mnt/obsidian_esp_a_config"
        run_command(f"mkdir -p {esp_a_config_mount_dir}")
        try:
            run_command(f"mount {part1} {esp_a_config_mount_dir}")
            run_command(f"mkdir -p {esp_a_config_mount_dir}/loader/entries")
            with open(f"{esp_a_config_mount_dir}/loader/loader.conf", "w") as f:
                f.write(loader_conf)
            with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
                f.write(entry_a_conf)
            with open(f"{esp_a_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
                f.write(entry_b_conf)
        finally:
            run_command(f"umount {esp_a_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_a_config_mount_dir}", check=False)

        print("Writing boot configuration to ESP_B...")
        esp_b_config_mount_dir = "/mnt/obsidian_esp_b_config"
        run_command(f"mkdir -p {esp_b_config_mount_dir}")
        try:
            run_command(f"mount {part2} {esp_b_config_mount_dir}")
            run_command(f"mkdir -p {esp_b_config_mount_dir}/loader/entries")
            with open(f"{esp_b_config_mount_dir}/loader/loader.conf", "w") as f:
                f.write(loader_conf)
            with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-a.conf", "w") as f:
                f.write(entry_a_conf)
            with open(f"{esp_b_config_mount_dir}/loader/entries/obsidian-b.conf", "w") as f:
                f.write(entry_b_conf)
        finally:
            run_command(f"umount {esp_b_config_mount_dir}", check=False)
            run_command(f"rm -r {esp_b_config_mount_dir}", check=False)
            run_command(f"rm -r {mount_dir}", check=False)
    print("\nInstallation complete!")
    print("Default boot order will attempt Slot A, then Slot B.")
    print("Reboot your system to apply changes.")

def handle_switch(args):
    checkroot()
    slot = args.slot
    print(f"Switching active boot slot to '{slot}'...")
    esp_a_path = lordo("ESP_A")
    esp_b_path = lordo("ESP_B")
    if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
        print(
            "ESP partitions not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    if is_systemd_boot():
        esp_a_path = lordo("ESP_A")
        esp_b_path = lordo("ESP_B")
        if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
            print(
                "ESP partitions not found. Was the system installed with obsidianctl?",
                file=sys.stderr,
            )
            sys.exit(1)

        esp_mount_dir = "/mnt/obsidian_esp_tmp"
        run_command(f"mkdir -p {esp_mount_dir}")
        try:
            run_command(f"mount {esp_a_path} {esp_mount_dir}")
            run_command(
                f"bootctl --esp-path={esp_mount_dir} set-default obsidian-{slot}.conf"
            )
            print(f"Default boot entry set to obsidian-{slot}.conf on ESP_A.")
        finally:
            run_command(f"umount {esp_mount_dir}", check=False)

        try:
            run_command(f"mount {esp_b_path} {esp_mount_dir}")
            run_command(
                f"bootctl --esp-path={esp_mount_dir} set-default obsidian-{slot}.conf"
            )
            print(f"Default boot entry set to obsidian-{slot}.conf on ESP_B.")
        finally:
            run_command(f"umount {esp_mount_dir}", check=False)
            run_command(f"rm -r {esp_mount_dir}", check=False)
    elif is_grub_active():
        grub_entry = f"ObsidianOS (Slot {slot.upper()})"
        try:
            run_command(f"grub-set-default \"{grub_entry}\"")
            print(f"Default GRUB boot entry set to '{grub_entry}'.")
        except Exception as e:
            print(f"Error setting GRUB default entry: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        print("Neither systemd-boot nor GRUB detected as active bootloader.", file=sys.stderr)
        sys.exit(1)
    
def handle_switchonce(args):
    checkroot()
    slot = args.slot
    print(f"Switching active boot slot to '{slot}' temporarily...")
    esp_a_path = lordo("ESP_A")
    esp_b_path = lordo("ESP_B")
    if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
        print(
            "ESP partitions not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    if is_systemd_boot():
        esp_a_path = lordo("ESP_A")
        esp_b_path = lordo("ESP_B")
        if not os.path.exists(esp_a_path) or not os.path.exists(esp_b_path):
            print(
                "ESP partitions not found. Was the system installed with obsidianctl?",
                file=sys.stderr,
            )
            sys.exit(1)

        esp_mount_dir = "/mnt/obsidian_esp_tmp"
        run_command(f"mkdir -p {esp_mount_dir}")
        try:
            run_command(f"mount {esp_a_path} {esp_mount_dir}")
            run_command(
                f"bootctl --esp-path={esp_mount_dir} set-oneshot obsidian-{slot}.conf"
            )
            print(f"Default boot entry set to obsidian-{slot}.conf on ESP_A.")
        finally:
            run_command(f"umount {esp_mount_dir}", check=False)

        try:
            run_command(f"mount {esp_b_path} {esp_mount_dir}")
            run_command(
                f"bootctl --esp-path={esp_mount_dir} set-oneshot obsidian-{slot}.conf"
            )
            print(f"Default boot entry set to obsidian-{slot}.conf on ESP_B.")
        finally:
            run_command(f"umount {esp_mount_dir}", check=False)
            run_command(f"rm -r {esp_mount_dir}", check=False)
    elif is_grub_active():
        grub_entry = f"ObsidianOS (Slot {slot.upper()})"
        try:
            run_command(f"grub-reboot \"{grub_entry}\"")
            print(f"GRUB boot entry for next reboot set to '{grub_entry}'.")
        except Exception as e:
            print(f"Error setting GRUB reboot entry: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        print("Neither systemd-boot nor GRUB detected as active bootloader.", file=sys.stderr)
        sys.exit(1)

def handle_update_mkobsidiansfs(args):
    if shutil.which("mkobsidiansfs"):
        os.system(f"mkobsidiansfs {args.system_sfs} system.sfs")
    else:
        if shutil.which("git"):
            os.system(
                f"git clone https://github.com/Obsidian-OS/mkobsidiansfs/ /tmp/mkobsidiansfs;chmod u+x /tmp/mkobsidiansfs/mkobsidiansfs;/tmp/mkobsidiansfs/mkobsidiansfs {args.system_sfs} tmp_system.sfs"
            )
        else:
            print(
                "No git or mkobsidiansfs found. Please install one of these to directly pass in an .mkobsfs."
            )
            sys.exit(1)
    args.system_sfs = "system.sfs"
    handle_update(args)
    os.remove("system.sfs")


def handle_update(args):
    checkroot()
    fstype = subprocess.run(
        [
            "blkid",
            "-s",
            "TYPE",
            "-o",
            "value",
            subprocess.run(
                ["findmnt", "-no", "SOURCE", "/"], capture_output=True, text=True
            ).stdout.strip(),
        ],
        capture_output=True,
        text=True,
    ).stdout.strip()
    slot = args.slot
    system_sfs = args.system_sfs
    if not os.path.exists(system_sfs):
        print(f"Error: System image '{system_sfs}' not found.", file=sys.stderr)
        sys.exit(1)
    _, ext = os.path.splitext(system_sfs)
    if ext == ".mkobsfs":
        handle_update_mkobsidiansfs(args)
        sys.exit()
    target_label = f"root_{slot}"
    esp_label = f"ESP_{slot.upper()}"
    print(f"Updating slot '{slot}' with image '{system_sfs}'...")
    print(f"WARNING: THIS WILL ERASE ALL OF SLOT {slot.upper()}. INCLUDING /root.")
    confirm = input("Continue? (y/N): ")
    if confirm.lower() != "y":
        print("Operation Canceled.")
        exit(1)
    print("Formatting partition...")
    run_command(f"mkfs.{fstype} -F -L {target_label} /dev/disk/by-label/{target_label}")
    mount_dir = f"/mnt/obsidian_update_{slot}"
    run_command(f"mkdir -p {mount_dir}")
    try:
        print(f"Mounting partition for slot '{slot}'...")
        run_command(f"mount /dev/disk/by-label/{target_label} {mount_dir}")
        print(f"Extracting system from {system_sfs} to slot '{slot}'...")
        run_command(f"unsquashfs -f -d {mount_dir} -no-xattrs {system_sfs}")
        print(f"Generating fstab for slot '{slot}'...")
        fstab_content = f"""
LABEL={target_label}  /      {fstype}  defaults,noatime 0 1
LABEL={esp_label}     /boot  vfat  defaults,noatime 0 2
LABEL=etc_ab  /etc   {fstype}  defaults,noatime 0 2
LABEL=var_ab  /var   {fstype}  defaults,noatime 0 2
LABEL=home_ab /home  {fstype}  defaults,noatime 0 2
"""
        fstab_path = f"{mount_dir}/etc/fstab"
        if not os.path.exists(os.path.dirname(fstab_path)):
            run_command(f"mkdir -p {os.path.dirname(fstab_path)}")

        with open(fstab_path, "w") as f:
            f.write(fstab_content.strip())
        print(f"Copying support files to slot '{slot}'...")
        script_path = os.path.realpath(sys.argv[0])
        obsidianctl_dest = f"{mount_dir}/usr/bin/obsidianctl"
        run_command(f"mkdir -p {mount_dir}/usr/bin")
        run_command(f"cp {script_path} {obsidianctl_dest}")
        run_command(f"chmod +x {obsidianctl_dest}")
        run_command(f"cp /etc/os-release {mount_dir}/etc/os-release")

        print(f"Populating ESP_{slot.upper()} with new boot files...")
        esp_tmp_mount = "/mnt/obsidian_esp_tmp"
        run_command(f"mkdir -p {esp_tmp_mount}")
        try:
            run_command(f"mount /dev/disk/by-label/ESP_{slot.upper()} {esp_tmp_mount}")
            run_command(f"rsync -aK --delete {mount_dir}/boot/ {esp_tmp_mount}/")
        finally:
            run_command(f"umount {esp_tmp_mount}", check=False)
            run_command(f"rmdir {esp_tmp_mount}", check=False)

        if is_grub_active():
            print(f"Updating GRUB configuration for slot '{slot}'...")
            grub_mount_dir = f"/mnt/obsidian_grub_update_{slot}"
            run_command(f"mkdir -p {grub_mount_dir}")
            try:
                run_command(f"mount /dev/disk/by-label/{target_label} {grub_mount_dir}")
                run_command(f"mount /dev/disk/by-label/{esp_label} {grub_mount_dir}/boot")
                run_command(f"arch-chroot {grub_mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
            finally:
                run_command(f"umount -R {grub_mount_dir}", check=False)
                run_command(f"rm -r {grub_mount_dir}", check=False)

    finally:
        print("Unmounting partition...")
        run_command(f"umount -R {mount_dir}", check=False)
        run_command(f"rm -r {mount_dir}", check=False)

    print(f"Update for slot '{slot}' complete!")
    print("You may need to switch to this slot and reboot to use the updated system.")
    if args.switch:
        print(f"Switching the active slot to {slot.upper()}")
        run_command(f"obsidianctl switch {slot}", check=False)

def handle_sync(args):
    check_dependencies(
        [
            "findfs",
            "blkid",
            "rsync",
            "tune2fs",
            "sgdisk",
            "lsblk",
            "e2label",
            "fatlabel",
        ]
    )
    checkroot()
    target_slot = args.slot
    current_slot = get_current_slot()
    if target_slot == current_slot:
        print(f"Error: Cannot sync slot {current_slot} to itself.", file=sys.stderr)
        sys.exit(1)

    print(f"Current slot: {current_slot}")
    print(f"Target slot: {target_slot}")
    source_root_label = f"root_{current_slot.lower()}"
    target_root_label = f"root_{target_slot.lower()}"
    source_esp_label = f"ESP_{current_slot.upper()}"
    target_esp_label = f"ESP_{target_slot.upper()}"
    try:
        source_root_dev = lordo(source_root_label)
        target_root_dev = lordo(target_root_label)
        source_esp_dev  = lordo(source_esp_label )
        target_esp_dev  = lordo(target_esp_label )
    except subprocess.CalledProcessError as e:
        print(f"Error: Could not find partitions by label. {e}", file=sys.stderr)
        sys.exit(1)

    if not all([source_root_dev, target_root_dev, source_esp_dev, target_esp_dev]):
        print(
            "Error: Could not find one or more source or target partitions by label.",
            file=sys.stderr,
        )
        sys.exit(1)

    print(f"Source root device: {source_root_dev}")
    print(f"Target root device: {target_root_dev}")
    print(f"Source ESP device: {source_esp_dev}")
    print(f"Target ESP device: {target_esp_dev}")
    print("Copying data from source root to target root. This may take a while...")
    source_mount_point = "/mnt/obsidian_source_root"
    target_mount_point = "/mnt/obsidian_target_root"
    run_command(f"mkdir -p {source_mount_point} {target_mount_point}")
    try:
        run_command(f"mount {source_root_dev} {source_mount_point}")
        run_command(f"mount {target_root_dev} {target_mount_point}")
        run_command(f"rsync -aHAX --inplace --delete --info=progress2 {source_mount_point}/ {target_mount_point}/")
    finally:
        run_command(f"umount {source_mount_point}", check=False)
        run_command(f"umount {target_mount_point}", check=False)
        run_command(f"rm -r {source_mount_point} {target_mount_point}", check=False)

    print(f"Setting label of {target_root_dev} to {target_root_label}")
    run_command(f"e2label {target_root_dev} {target_root_label}")

    print("Copying data from source ESP to target ESP...")
    source_esp_mount_point = "/mnt/obsidian_source_esp"
    target_esp_mount_point = "/mnt/obsidian_target_esp"
    run_command(f"mkdir -p {source_esp_mount_point} {target_esp_mount_point}")
    try:
        run_command(f"mount {source_esp_dev} {source_esp_mount_point}")
        run_command(f"mount {target_esp_dev} {target_esp_mount_point}")
        run_command(f"rsync -aHAX --inplace --delete --info=progress2 {source_esp_mount_point}/ {target_esp_mount_point}/")
    finally:
        run_command(f"umount {source_esp_mount_point}", check=False)
        run_command(f"umount {target_esp_mount_point}", check=False)
        run_command(f"rm -r {source_esp_mount_point} {target_esp_mount_point}", check=False)

    print(f"Setting label of {target_esp_dev} to {target_esp_label}")
    run_command(f"fatlabel {target_esp_dev} {target_esp_label}")

    if is_grub_active():
        print(f"Updating GRUB configuration for slot '{target_slot}'...")
        grub_mount_dir = f"/mnt/obsidian_grub_sync_{target_slot}"
        run_command(f"mkdir -p {grub_mount_dir}")
        try:
            run_command(f"mount {target_root_dev} {grub_mount_dir}")
            run_command(f"mount {target_esp_dev} {grub_mount_dir}/boot")
            run_command(f"mount --bind /etc {grub_mount_dir}/etc")
            run_command(f"arch-chroot {grub_mount_dir} grub-mkconfig -o /boot/grub/grub.cfg")
        finally:
            run_command(f"umount -R {grub_mount_dir}", check=False)
            run_command(f"rm -r {grub_mount_dir}", check=False)

    print("Sync complete.")

import os
import subprocess
import shutil
import sys
import time

def handle_enter(args):
    if os.geteuid() != 0:
        print("This command must be run as root.", file=sys.stderr)
        sys.exit(1)

    slot = args.slot
    root_label = f"root_{slot}"
    esp_label = f"ESP_{slot.upper()}"
    root_partition = lordo(root_label)
    esp_partition = lordo(esp_label)
    mount_point = f"/mnt/obsidian_{slot}"
    if not os.path.exists(root_partition):
        print(f"Root partition for slot {slot} ({root_partition}) not found.", file=sys.stderr)
        sys.exit(1)
    if not os.path.exists(esp_partition):
        print(f"ESP for slot {slot} ({esp_partition}) not found.", file=sys.stderr)
        sys.exit(1)

    if not os.path.exists(mount_point):
        os.makedirs(mount_point)

    try:
        subprocess.run(["mount", root_partition, mount_point], check=True)
        subprocess.run(["mount", esp_partition, f"{mount_point}/boot", "--mkdir"], check=True)

        for shared_part in ["etc_ab", "var_ab", "home_ab"]:
            shared_partition = lordo(shared_part)
            if os.path.exists(shared_partition):
                fs_dir = shared_part.split("_")[0]
                target_mount = os.path.join(mount_point, fs_dir)
                if not os.path.exists(target_mount):
                    os.makedirs(target_mount)
                subprocess.run(["mount", shared_partition, target_mount], check=True)

        if shutil.which("arch-chroot"): 
            cmd = ["arch-chroot"]
            if not args.enable_networking:
                cmd.append("-r")
            
            cmd.append(mount_point)
            subprocess.run(cmd, check=True)
        else:
            print("WARNING: arch-chroot not found, performing manual chroot...")
            if args.mount_essentials:
                for essential_fs in ["proc", "sys", "dev", "dev/pts", "dev/shm"]:
                    target_mount = os.path.join(mount_point, essential_fs)
                    if not os.path.exists(target_mount):
                        os.makedirs(target_mount, exist_ok=True)
                    subprocess.run(["mount", "--bind", f"/{essential_fs}", target_mount], check=True)

            if args.enable_networking:
                if os.path.exists("/etc/resolv.conf"):
                    os.makedirs(os.path.join(mount_point, "etc"), exist_ok=True)
                    subprocess.run(["cp", "/etc/resolv.conf", os.path.join(mount_point, "etc/resolv.conf")], check=True)

            if args.mount_home:
                home_mount = os.path.join(mount_point, "home")
                if not os.path.exists(home_mount):
                    os.makedirs(home_mount)
                subprocess.run(["mount", "--bind", "/home", home_mount], check=True)
            
            if args.mount_root:
                root_mount = os.path.join(mount_point, "root")
                if not os.path.exists(root_mount):
                    os.makedirs(root_mount)
                subprocess.run(["mount", "--bind", "/root", root_mount], check=True)

            os.chroot(mount_point)
            os.chdir("/")
            shell = os.environ.get("SHELL", "/bin/bash")
            subprocess.run([shell], check=True)

    finally:
        print("Exiting...")
        for i in range(5):
            try:
                subprocess.run(["umount", "-R", mount_point], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                break
            except subprocess.CalledProcessError:
                time.sleep(1)
        
        if os.path.ismount(mount_point):
            print(f"Could not unmount {mount_point}. Please unmount it manually.", file=sys.stderr)

def handle_netupdate(args):
    checkroot()
    if args.break_system or not os.path.exists(
        "/etc/obsidianctl-netupdate-enable-DONOTDELETE"
    ):
        print(
            "Error: Image not found to be default image. It is not reccomended to continue.",
            file=sys.stderr,
        )
        print(
            "If you would like to continue... REMOVING ALL NON DEFAULT PACKAGES AND USERS, add the --break-system flag.",
            file=sys.stderr,
        )
        sys.exit(1)
    print("Starting image netupdate...")
    print("Getting latest image...")
    os.system(
        "curl https://github.com/Obsidian-OS/archiso/releases/download/latest/system.sfs -o /tmp/system.sfs"
    )
    handle_update(argparse.Namespace(slot=args.slot, system_sfs="/tmp/system.sfs"))

def handle_slot_diff(args):
    checkroot()
    current = get_current_slot()
    inactive = "b" if current == "a" else "a"
    mount_current = f"/mnt/obsidian_slot_{current}"
    mount_inactive = f"/mnt/obsidian_slot_{inactive}"
    os.makedirs(mount_current, exist_ok=True)
    os.makedirs(mount_inactive, exist_ok=True)
    part_current = lordo(f"root_{current}")
    part_inactive = lordo(f"root_{inactive}")
    run_command(f"mount {part_current} {mount_current}")
    run_command(f"mount {part_inactive} {mount_inactive}")
    kernel_current = "unknown"
    kernel_inactive = "unknown"
    boot_current = os.path.join(mount_current, "boot")
    boot_inactive = os.path.join(mount_inactive, "boot")
    if os.path.exists(boot_current):
        for f in os.listdir(boot_current):
            if f.startswith("vmlinuz"):
                kernel_current = f.replace("vmlinuz-", "")
    if os.path.exists(boot_inactive):
        for f in os.listdir(boot_inactive):
            if f.startswith("vmlinuz"):
                kernel_inactive = f.replace("vmlinuz-", "")

    pkgs_current = set()
    pkgs_inactive = set()
    pacman_current = os.path.join(mount_current, "var/lib/pacman/local")
    pacman_inactive = os.path.join(mount_inactive, "var/lib/pacman/local")
    if os.path.exists(pacman_current):
        pkgs_current = {d.split("-")[0] for d in os.listdir(pacman_current)}
    if os.path.exists(pacman_inactive):
        pkgs_inactive = {d.split("-")[0] for d in os.listdir(pacman_inactive)}

    added = sorted(pkgs_inactive - pkgs_current)
    removed = sorted(pkgs_current - pkgs_inactive)
    print(f">> {current}->{inactive} Kernel: {kernel_current}->{kernel_inactive}")
    print(f">> Packages {current}->{inactive}:")
    for p in added:
        print(f"+ {p}")
    for p in removed:
        print(f"- {p}")

    run_command(f"umount {mount_current}")
    run_command(f"umount {mount_inactive}")
    os.rmdir(mount_current)
    os.rmdir(mount_inactive)

import os
import sys
import shutil
from datetime import datetime
import json
import subprocess
def handle_backup_slot(args):
    checkroot()
    slot = args.slot
    backup_dir = args.backup_dir or f"/var/backups/obsidianctl/slot_{slot}"
    device = args.device or None
    full_backup = args.full_backup
    print(f"Creating backup of slot '{slot}'...")
    if full_backup:
        print("FULL backup enabled.")
    part_path = lordo(f"root_{slot}", device)
    esp_path  = lordo(f"ESP_{slot.upper()}", device)
    home_path = lordo(f"home_ab", device)
    etc_path  = lordo(f"etc_ab", device)
    var_path  = lordo(f"var_ab", device)
    if not os.path.exists(part_path):
        print(
            f"Error: Slot '{slot}' not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    backup_name = f"slot_{slot}_backup_{timestamp}"
    backup_path = os.path.join(backup_dir, backup_name)
    run_command(f"mkdir -p {backup_dir}")
    mount_dir = f"/mnt/obsidian_backup_{slot}"
    run_command(f"mkdir -p {mount_dir}")
    try:
        run_command(f"mount {part_path} {mount_dir}")
        if full_backup:
            run_command(f"mount {var_path}  {mount_dir}/var" )
            run_command(f"mount {etc_path}  {mount_dir}/etc" )
            run_command(f"mount {esp_path}  {mount_dir}/boot")
            run_command(f"mount {home_path} {mount_dir}/home")
        print(f"Creating backup archive at {backup_path}.sfs...")
        run_command(
            f"mksquashfs {mount_dir} {backup_path}.sfs -comp xz -noappend -wildcards -e proc/* sys/* dev/* run/* tmp/* mnt/* media/* lost+found"
        )

        metadata = {
            "slot": slot,
            "timestamp": timestamp,
            "backup_path": f"{backup_path}.sfs",
            "size": os.path.getsize(f"{backup_path}.sfs"),
            "kernel": "unknown",
            "packages": [],
            "is_full_backup": full_backup,
        }

        boot_dir = os.path.join(mount_dir, "boot")
        if os.path.exists(boot_dir):
            for f in os.listdir(boot_dir):
                if f.startswith("vmlinuz"):
                    metadata["kernel"] = f.replace("vmlinuz-", "")
                    break

        pacman_dir = os.path.join(mount_dir, "var/lib/pacman/local")
        if os.path.exists(pacman_dir):
            metadata["packages"] = [
                d
                for d in os.listdir(pacman_dir)
                if os.path.isdir(os.path.join(pacman_dir, d))
            ]

        with open(f"{backup_path}.json", "w") as f:
            json.dump(metadata, f, indent=2)

        print(f"Backup completed successfully!")
        print(f"Archive: {backup_path}.sfs")
        print(f"Metadata: {backup_path}.json")
        print(f"Size: {metadata['size'] / (1024*1024):.1f} MB")

    finally:
        run_command(f"umount -R {mount_dir}", check=True)
        run_command(f"rm -rf {mount_dir}", check=False)


def handle_rollback_slot(args):
    checkroot()
    slot = args.slot
    backup_path = args.backup_path
    if not backup_path:
        print("Error: Please specify a backup path with --backup-path", file=sys.stderr)
        sys.exit(1)

    if not backup_path.endswith(".sfs"):
        backup_path += ".sfs"

    if not os.path.exists(backup_path):
        print(f"Error: Backup file '{backup_path}' not found.", file=sys.stderr)
        sys.stderr.write(f"Error: Backup file '{backup_path}' not found.")
        sys.exit(1)

    metadata_path = backup_path.replace(".sfs", ".json")
    is_full_backup = False
    if os.path.exists(metadata_path):
        try:
            with open(metadata_path, "r") as f:
                metadata = json.load(f)
            is_full_backup = metadata.get("is_full_backup", False)
        except json.JSONDecodeError:
            print(f"Warning: Could not read metadata from {metadata_path}. Assuming not a full backup.", file=sys.stderr)

    print(f"Rolling back slot '{slot}' from backup: {backup_path}")
    part_path = lordo(f"root_{slot}", device)
    esp_path  = lordo(f"ESP_{slot.upper()}", device)
    home_path = lordo(f"home_ab", device)
    etc_path  = lordo(f"etc_ab", device)
    var_path  = lordo(f"var_ab", device)
    if not os.path.exists(part_path):
        print(
            f"Error: Slot '{slot}' not found. Was the system installed with obsidianctl?",
            file=sys.stderr,
        )
        sys.exit(1)

    print("WARNING: This will completely overwrite slot '{slot}' with the backup.")
    if is_full_backup:
        print("         This is a FULL system restore and will also affect ESP, home, etc, and var partitions if they exist.")
    confirm = input("Are you sure you want to proceed? (y/N): ")
    if confirm.lower() != "y":
        print("Rollback aborted.")
        sys.exit(0)

    mount_dir = f"/mnt/obsidian_rollback_{slot}"
    run_command(f"mkdir -p {mount_dir}")
    temp_extract_dir = f"/mnt/obsidian_temp_extract_{slot}"
    run_command(f"mkdir -p {temp_extract_dir}")
    try:
        print("Extracting backup to temporary location...")
        run_command(f"unsquashfs -d {temp_extract_dir} {backup_path}")
        fstype_result = subprocess.run(["blkid","-s","TYPE","-o","value",subprocess.run(["findmnt","-no","SOURCE","/"],capture_output=True,text=True).stdout.strip()],capture_output=True,text=True)
        fstype = fstype_result.stdout.strip()
        if not fstype:
            fstype = "ext4"
            print(f"Warning: Could not determine filesystem type for root partition. Defaulting to {fstype} for formatting.")

        run_command(f"umount {part_path}", check=True)
        print(f"Formatting root partition {part_path} with {fstype} and label root_{slot}...")
        run_command(f"mkfs.{fstype} -F {part_path} -L root_{slot}")
        run_command(f"mount {part_path} {mount_dir}")
        print("Copying root filesystem contents...")
        run_command(f"rsync -aAXv --exclude=/boot --exclude=/home --exclude=/etc --exclude=/var {temp_extract_dir}/ {mount_dir}/")
        if is_full_backup:
            partitions_to_restore = {
                "ESP": {"path": esp_path, "source_dir": "boot"},
                "home": {"path": home_path, "source_dir": "home"},
                "etc": {"path": etc_path, "source_dir": "etc"},
                "var": {"path": var_path, "source_dir": "var"},
            }

            for name, info in partitions_to_restore.items():
                p_path = info["path"]
                src_dir = os.path.join(temp_extract_dir, info["source_dir"])
                if os.path.exists(p_path) and os.path.isdir(src_dir):
                    print(f"Restoring {name} partition {p_path}...")
                    confirm_part = input(f"Are you sure you want to format and restore {name} partition {p_path}? (y/N): ")
                    if confirm_part.lower() == "y":
                        run_command(f"umount {p_path}", check=True)
                        part_fstype_result = subprocess.run(["blkid","-s","TYPE","-o","value",p_path],capture_output=True,text=True)
                        part_fstype = part_fstype_result.stdout.strip()
                        if not part_fstype:
                            part_fstype = "ext4"
                            print(f"Warning: Could not determine filesystem type for {p_path}. Defaulting to {part_fstype} for formatting.")

                        label_option = "-L"
                        label_value = ""
                        if name == "ESP":
                            label_value = f"ESP_{slot.upper()}"
                            if part_fstype in ["vfat", "fat"]:
                                label_option = "-n"
                            else:
                                label_option = "-L"
                        else:
                            label_value = f"{name}_ab"

                        print(f"Formatting {name} partition {p_path} with {part_fstype} and label {label_value}...")
                        run_command(f"mkfs.{part_fstype} -F {p_path} {label_option} {label_value}")

                        temp_part_mount_dir = f"/mnt/obsidian_temp_part_mount_{name}_{slot}"
                        run_command(f"mkdir -p {temp_part_mount_dir}")
                        run_command(f"mount {p_path} {temp_part_mount_dir}")
                        run_command(f"rsync -aAXv {src_dir}/ {temp_part_mount_dir}/")
                        run_command(f"umount {temp_part_mount_dir}")
                        run_command(f"rmdir {temp_part_mount_dir}")
                    else:
                        print(f"Skipping restoration of {name} partition.")
                else:
                    print(f"Skipping restoration of {name} partition: partition {p_path} not found or source directory {src_dir} missing.")

        fstab_path = os.path.join(mount_dir, "etc/fstab")
        if os.path.exists(fstab_path):
            with open(fstab_path, "r") as f:
                fstab_content = f.read()

            if slot == "a":
                fstab_content = fstab_content.replace(
                    "LABEL=root_b", "LABEL=root_a"
                ).replace("LABEL=ESP_B", "LABEL=ESP_A")
            else:
                fstab_content = fstab_content.replace(
                    "LABEL=root_a", "LABEL=root_b"
                ).replace("LABEL=ESP_A", "LABEL=ESP_B")

            with open(fstab_path, "w") as f:
                f.write(fstab_content)

        print(f"Rollback completed successfully!")
    finally:
        run_command(f"umount -R {mount_dir}", check=True)
        run_command(f"rmdir {mount_dir}", check=False)
        run_command(f"rm -rf {temp_extract_dir}", check=False)


import os
import sys
import subprocess

def handle_health_check(args):
    """Check the health of both A/B slots"""
    print(" Performing system health check...")
    print("=" * 50)
    
    # Check if we're running from an obsidianctl-managed system
    if not os.path.exists("/dev/disk/by-label/root_a") or not os.path.exists("/dev/disk/by-label/root_b"):
        print(" Error: This system was not installed with obsidianctl")
        print("   Health check requires A/B slot configuration")
        sys.exit(1)
    
    current_slot = get_current_slot()
    print(f" Current active slot: {current_slot.upper()}")
    
    # Check both slots
    slots_status = {}
    for slot in ["a", "b"]:
        print(f"\n Checking slot {slot.upper()}...")
        status = check_slot_health(slot)
        slots_status[slot] = status
        print_slot_status(slot, status)
    
    # Overall health assessment
    print("\n" + "=" * 50)
    print(" OVERALL HEALTH ASSESSMENT")
    print("=" * 50)
    
    healthy_slots = sum(1 for status in slots_status.values() if status["overall"] == "healthy")
    total_slots = len(slots_status)
    
    if healthy_slots == total_slots:
        print(" All slots are healthy!")
        print(" System is in optimal condition")
    elif healthy_slots > 0:
        print(f"  {healthy_slots}/{total_slots} slots are healthy")
        print(" Some maintenance may be needed")
    else:
        print(" No healthy slots detected!")
        print(" System requires immediate attention")
    
    return slots_status

def check_slot_health(slot):
    """Check the health of a specific slot"""
    status = {
        "overall": "unknown",
        "bootable": False,
        "filesystem": "unknown",
        "kernel": "unknown",
        "packages": "unknown",
        "errors": []
    }
    
    part_path = f"/dev/disk/by-label/root_{slot}"
    
    # Check if partition exists
    if not os.path.exists(part_path):
        status["errors"].append("Partition not found")
        status["overall"] = "critical"
        return status
    
    # Check filesystem integrity
    try:
        result = run_command(f"e2fsck -n {part_path}", capture_output=True, check=False)
        if result.returncode == 0:
            status["filesystem"] = "healthy"
        else:
            status["filesystem"] = "needs_repair"
            status["errors"].append("Filesystem has errors")
    except Exception as e:
        status["filesystem"] = "unknown"
        status["errors"].append(f"Filesystem check failed: {e}")
    
    # Check if slot is bootable
    esp_path = f"/dev/disk/by-label/ESP_{slot.upper()}"
    if os.path.exists(esp_path):
        # Check for bootloader files
        mount_dir = f"/mnt/health_check_esp_{slot}"
        try:
            run_command(f"mkdir -p {mount_dir}")
            run_command(f"mount {esp_path} {mount_dir}")
            
            boot_files = ["loader/loader.conf", "loader/entries/obsidian-a.conf", "loader/entries/obsidian-b.conf"]
            missing_files = []
            
            for boot_file in boot_files:
                if not os.path.exists(os.path.join(mount_dir, boot_file)):
                    missing_files.append(boot_file)
            
            if not missing_files:
                status["bootable"] = True
            else:
                status["errors"].append(f"Missing boot files: {', '.join(missing_files)}")
                
        finally:
            run_command(f"umount {mount_dir}", check=False)
            run_command(f"rmdir {mount_dir}", check=False)
    else:
        status["errors"].append("ESP partition not found")
    
    # Check kernel and packages
    mount_dir = f"/mnt/health_check_{slot}"
    try:
        run_command(f"mkdir -p {mount_dir}")
        run_command(f"mount {part_path} {mount_dir}")
        
        # Check kernel
        boot_dir = os.path.join(mount_dir, "boot")
        if os.path.exists(boot_dir):
            kernels = [f for f in os.listdir(boot_dir) if f.startswith("vmlinuz")]
            if kernels:
                status["kernel"] = kernels[0].replace("vmlinuz-", "")
            else:
                status["errors"].append("No kernel found")
        else:
            status["errors"].append("Boot directory not found")
        
        # Check packages
        pacman_dir = os.path.join(mount_dir, "var/lib/pacman/local")
        if os.path.exists(pacman_dir):
            package_count = len([d for d in os.listdir(pacman_dir) if os.path.isdir(os.path.join(pacman_dir, d))])
            status["packages"] = f"{package_count} packages"
        else:
            status["packages"] = "unknown"
            
    except Exception as e:
        status["errors"].append(f"Mount check failed: {e}")
    finally:
        run_command(f"umount {mount_dir}", check=False)
        run_command(f"rmdir {mount_dir}", check=False)
    
    # Determine overall health
    if status["errors"]:
        if len(status["errors"]) > 2:
            status["overall"] = "critical"
        else:
            status["overall"] = "warning"
    else:
        status["overall"] = "healthy"
    
    return status

def print_slot_status(slot, status):
    """Print the status of a slot in a user-friendly format"""
    health_icons = {
        "healthy": "",
        "warning": "",
        "critical": "",
        "unknown": ""
    }
    
    print(f"   {health_icons[status['overall']]} Overall: {status['overall'].upper()}")
    print(f"    Bootable: {'Yes' if status['bootable'] else 'No'}")
    print(f"    Filesystem: {status['filesystem']}")
    print(f"    Kernel: {status['kernel']}")
    print(f"    Packages: {status['packages']}")
    
    if status["errors"]:
        print(f"     Issues:")
        for error in status["errors"]:
            print(f"       {error}")

def handle_verify_integrity(args):
    """Verify the integrity of a specific slot"""
    slot = args.slot
    print(f" Verifying integrity of slot {slot.upper()}...")
    
    part_path = f"/dev/disk/by-label/root_{slot}"
    if not os.path.exists(part_path):
        print(f" Error: Slot '{slot}' not found", file=sys.stderr)
        sys.exit(1)
    
    print(" Running filesystem integrity check...")
    try:
        # Run read-only filesystem check
        result = run_command(f"e2fsck -n {part_path}", capture_output=True, check=False)
        
        if result.returncode == 0:
            print(" Filesystem integrity check passed")
        else:
            print(" Filesystem integrity check failed")
            print(f"   Exit code: {result.returncode}")
            if result.stderr:
                print(f"   Errors: {result.stderr}")
            sys.exit(1)
            
    except Exception as e:
        print(f" Integrity check failed: {e}", file=sys.stderr)
        sys.exit(1)
    
    print(" Checking for corrupted files...")
    mount_dir = f"/mnt/integrity_check_{slot}"
    corrupted_files = []
    
    try:
        run_command(f"mkdir -p {mount_dir}")
        run_command(f"mount {part_path} {mount_dir}")
        
        # Check critical system files
        critical_files = [
            "/etc/fstab",
            "/etc/passwd",
            "/etc/group",
            "/etc/shadow",
            "/boot/vmlinuz-linux",
            "/boot/initramfs-linux.img"
        ]
        
        for file_path in critical_files:
            full_path = os.path.join(mount_dir, file_path.lstrip("/"))
            if os.path.exists(full_path):
                try:
                    with open(full_path, "rb") as f:
                        f.read(1024)  # Try to read first 1KB
                except Exception:
                    corrupted_files.append(file_path)
            else:
                corrupted_files.append(file_path)
        
        if corrupted_files:
            print(" Found corrupted or missing critical files:")
            for file_path in corrupted_files:
                print(f"    {file_path}")
            sys.exit(1)
        else:
            print(" All critical files are intact")
            
    finally:
        run_command(f"umount {mount_dir}", check=False)
        run_command(f"rmdir {mount_dir}", check=False)
    
    print(" Slot integrity verification completed successfully!") 
MOUNT_BASE_DIR = "/run/obsidianos-extensions"
FSTAB_PATH = "/etc/fstab"
OVERLAYS_CONF_PATH = "/etc/obsidianos-overlays.conf"
LIB_OVERLAYS_SO = "/usr/lib/libobsidianos_overlays.so"
FSTAB_MARKER_PREFIX = "# OBSIDIANOS_EXT:"
OVERLAYS_MARKER_PREFIX = "# OBSIDIANOS_EXT:"
USER_ENV_GENERATOR_DIR = os.path.join(get_user_home_dir(), ".config", "environment.d")
USER_ENV_GENERATOR_SCRIPT = f"{USER_ENV_GENERATOR_DIR}/99-obsidianos-overlays.conf"
LD_PRELOAD_LINE = "LD_PRELOAD=/usr/lib/libobsidianos_overlays.so"


def _check_lib_exists():
    if not os.path.exists(LIB_OVERLAYS_SO):
        print(f"Error: libobsidianos_overlays is not installed.", file=sys.stderr)
        sys.exit(1)


def _get_extension_name(path):
    return os.path.splitext(os.path.basename(path))[0]


def _read_file_lines(filepath):
    if not os.path.exists(filepath):
        return []
    with open(filepath, "r") as f:
        return f.readlines()


def _write_file_lines(filepath, lines):
    with open(filepath, "w") as f:
        f.writelines(lines)


def handle_add_extension(args):
    checkroot()
    _check_lib_exists()
    ext_path = args.path
    if not os.path.exists(ext_path):
        print(f"Error: Extension file '{ext_path}' not found.", file=sys.stderr)
        sys.exit(1)
    if not ext_path.endswith(".obsiext"):
        print(
            f"Error: Extension file '{ext_path}' must have a .obsiext extension.",
            file=sys.stderr,
        )
        sys.exit(1)

    ext_name = _get_extension_name(ext_path)
    dest_path = ext_path
    mount_point = os.path.join(MOUNT_BASE_DIR, ext_name)
    os.makedirs(mount_point, exist_ok=True)
    print(f"Using '{ext_path}' directly as extension source.")
    fstab_entry = f"{dest_path} {mount_point} squashfs defaults,ro,nofail 0 0 {FSTAB_MARKER_PREFIX}{ext_name}\n"
    overlays_entry = f"{mount_point} {OVERLAYS_MARKER_PREFIX}{ext_name}\n"
    fstab_lines = _read_file_lines(FSTAB_PATH)
    overlays_lines = _read_file_lines(OVERLAYS_CONF_PATH)
    for line in fstab_lines:
        if FSTAB_MARKER_PREFIX + ext_name in line:
            print(f"Extension '{ext_name}' already added.", file=sys.stderr)
            sys.exit(0)

    fstab_lines.append(fstab_entry)
    overlays_lines.append(overlays_entry)
    _write_file_lines(FSTAB_PATH, fstab_lines)
    _write_file_lines(OVERLAYS_CONF_PATH, overlays_lines)
    print(
        f"Extension '{ext_name}' added successfully.\nYou may need to reboot or run 'sudo mount -a' for changes to take effect."
    )


def handle_remove_extension(args):
    checkroot()
    _check_lib_exists()
    ext_name = args.name
    fstab_lines = _read_file_lines(FSTAB_PATH)
    overlays_lines = _read_file_lines(OVERLAYS_CONF_PATH)
    new_fstab_lines = []
    removed_fstab_entry = False
    for line in fstab_lines:
        if FSTAB_MARKER_PREFIX + ext_name in line:
            removed_fstab_entry = True
        else:
            new_fstab_lines.append(line)

    new_overlays_lines = []
    removed_overlays_entry = False
    mount_point_to_remove = None
    for line in overlays_lines:
        if OVERLAYS_MARKER_PREFIX + ext_name in line:
            removed_overlays_entry = True
            parts = line.split()
            if parts:
                mount_point_to_remove = parts[0]
        else:
            new_overlays_lines.append(line)

    if not removed_fstab_entry and not removed_overlays_entry:
        print(f"Extension '{ext_name}' not found.", file=sys.stderr)
        sys.exit(1)

    _write_file_lines(FSTAB_PATH, new_fstab_lines)
    _write_file_lines(OVERLAYS_CONF_PATH, new_overlays_lines)

    if mount_point_to_remove and os.path.exists(mount_point_to_remove):
        try:
            os.rmdir(mount_point_to_remove)
            print(f"Removed empty mount point directory '{mount_point_to_remove}'.")
        except OSError as e:
            print(
                f"Warning: Could not remove mount point directory '{mount_point_to_remove}': {e}",
                file=sys.stderr,
            )

    print(
        f"Extension '{ext_name}' removed successfully. You may need to reboot or run 'sudo umount <mount_point>' for changes to take effect."
    )


def handle_list_extensions(args):
    _check_lib_exists()
    fstab_lines = _read_file_lines(FSTAB_PATH)
    fstab_exts = set()
    for line in fstab_lines:
        match = re.search(rf"{FSTAB_MARKER_PREFIX}([\w\d\-\_]+)", line)
        if match:
            fstab_exts.add(match.group(1))

    all_exts = sorted(list(fstab_exts))
    if not all_exts:
        print("No ObsidianOS extensions found.")
        return

    print("ObsidianOS Extensions:")
    for ext in all_exts:
        print(f"- {ext}")

def handle_ext(args):
    if args.ext_command == "add":
        handle_add_extension(args)
    elif args.ext_command == "rm":
        handle_remove_extension(args)
    elif args.ext_command == "list":
        handle_list_extensions(args)
    elif args.ext_command == "enable":
        print("Not implemented yet. sorry but it was breaking systems. Use LD_PRELOAD yourself for now.")
    elif args.ext_command == "disable":
        print("Not implemented yet. sorry but it was breaking systems. Use LD_PRELOAD yourself for now.")
    else:
        print(
            "Invalid 'ext' command. Use 'add', 'rm', 'list', 'enable', or 'disable'.",
            file=sys.stderr,
        )
        sys.exit(1)

def handle_migrate(args):
    checkroot()
    migration_id = str(args.id)
    repo_url = args.repo.format(id=migration_id)

    applied_migrations = get_applied_migrations()
    if migration_id in applied_migrations and not args.force:
        print(f"Migration {migration_id} already applied. Use --force to re-run.")
        return

    print(f"Fetching Migration #{migration_id}...")
    with tempfile.NamedTemporaryFile(mode="w+", delete=False) as temp_script:
        temp_script_path = temp_script.name
        try:
            run_command(
                f'curl -fsSL -o {temp_script_path} {repo_url} -H "Cache-Control: no-cache"'
            )
        except Exception as e:
            print(f"Error: Failed to fetch migration script: {e}", file=sys.stderr)
            if os.path.exists(temp_script_path):
                os.remove(temp_script_path)
            sys.exit(1)

    run_command(f"chmod +x {temp_script_path}")

    print(f"Running migration #{migration_id}...")
    env = os.environ.copy()
    env["CTLPATH"] = os.path.abspath(__file__)
    env["MIGRATION_ID"] = migration_id
    env["MIGRATION_REPO"] = repo_url

    try:
        run_command(f"bash {temp_script_path}", env=env)
        record_applied_migration(migration_id)
        print(f"Migration #{migration_id} completed successfully.")
    except Exception as e:
        print(f"Error: Migration {migration_id} failed: {e}", file=sys.stderr)
        sys.exit(1)
    finally:
        os.remove(temp_script_path)


def handle_rollback(args):
    checkroot()
    migration_id = str(args.id)
    repo_url = args.repo.format(id=migration_id)
    rollback_url = repo_url.replace(
        f"migration-{migration_id}.sh", f"migration-{migration_id}-rollback.sh"
    )

    applied_migrations = get_applied_migrations()
    if migration_id not in applied_migrations:
        print(
            f"Warning: Migration {migration_id} has not been applied, cannot roll back.",
            file=sys.stderr,
        )
        return

    print(
        f"Fetching rollback script for migration {migration_id} from {rollback_url}..."
    )

    with tempfile.NamedTemporaryFile(mode="w+", delete=False) as temp_script:
        temp_script_path = temp_script.name
        try:
            run_command(f"curl -sSL -o {temp_script_path} {rollback_url}")
        except Exception as e:
            print(f"Error: Failed to fetch rollback script: {e}", file=sys.stderr)
            if os.path.exists(temp_script_path):
                os.remove(temp_script_path)
            sys.exit(1)

    run_command(f"chmod +x {temp_script_path}")

    print(f"Running rollback script for migration {migration_id}...")
    env = os.environ.copy()
    env["CTLPATH"] = os.path.abspath(__file__)
    env["MIGRATION_ID"] = migration_id
    env["MIGRATION_REPO"] = repo_url

    try:
        run_command(f"bash {temp_script_path}", env=env)
        remove_applied_migration(migration_id)
        print(f"Rollback for migration {migration_id} completed successfully.")
    except Exception as e:
        print(
            f"Error: Rollback for migration {migration_id} failed: {e}", file=sys.stderr
        )
        sys.exit(1)
    finally:
        os.remove(temp_script_path)


def handle_list_migrations(args):
    checkroot()
    applied_migrations = get_applied_migrations()
    if not applied_migrations:
        print("No migrations have been applied yet.")
        return

    print("Applied Migrations:")
    for migration_id in applied_migrations:
        print(f"- {migration_id}")

import argparse
import sys
def main():
    parser = argparse.ArgumentParser(
        description="Install and manage A/B slot system with shared partitions on ObsidianOS.",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    subparsers = parser.add_subparsers(dest="command", required=True)
    parser_status = subparsers.add_parser(
        "status", help="Show current active slot and system info."
    )
    parser_status.set_defaults(func=handle_status)

    parser_install = subparsers.add_parser(
        "install", help="Partition device and install system image."
    )
    parser_install.add_argument(
        "device", help="The target block device (e.g., /dev/sda)."
    )
    parser_install.add_argument("system_sfs", help="Path to the SquashFS system image. If you pass in an .mkobsfs file, it will download and run mkobsidiansfs.")
    parser_install.add_argument("--rootfs-size", default="5G", help="Size of the root partitions for slots a and b.")
    parser_install.add_argument("--etc-size", default="5G", help="Size of the shared etc partition.")
    parser_install.add_argument("--var-size", default="5G", help="Size of the shared var partition.")
    parser_install.add_argument("--esp-size", default="512M", help="Size of the ESP partitions for slots a and b.")
    parser_install.add_argument("--dual-boot", action="store_true", help="Setup a dual-boot configuration. (EXPERIMENTAL. USE AT YOUR OWN RISK.)")
    parser_install.add_argument("--use-f2fs", action="store_true", help="Setup an f2fs configuration.")
    parser_install.add_argument("--use-grub", action="store_true", help="Setup an grub configuration. (Does not do anything, as grub is the default.)")
    parser_install.add_argument("--use-systemdboot", action="store_true", help="Setup an (DEPRICATED) systemd-boot configuration.")
    parser_install.add_argument("--use-grub2", action="store_true", help="Setup an grub configuration, using grub2-install as some distros maintain both.")
    parser_install.set_defaults(func=handle_install) 
    parser_switchonce = subparsers.add_parser(
      "switch-once", help="Switch active boot slot to 'a' or 'b' once only."
    )
    parser_switchonce.add_argument(
        "slot", choices=["a", "b"], help="The slot to make active for once."
    )
    parser_switchonce.set_defaults(func=handle_switchonce)
        
    parser_switch = subparsers.add_parser(
        "switch", help="Switch active boot slot to 'a' or 'b'."
    )
    parser_switch.add_argument(
        "slot", choices=["a", "b"], help="The slot to make active."
    )
    parser_switch.set_defaults(func=handle_switch)

    parser_diff = subparsers.add_parser(
        "slot-diff", help="Show diff between the two slots."
    )
    parser_diff.set_defaults(func=handle_slot_diff)
    
    parser_backup = subparsers.add_parser(
        "backup-slot", help="Create a backup of a specific slot."
    )
    parser_backup.add_argument(
        "slot", choices=["a", "b"], help="The slot to backup."
    )
    parser_backup.add_argument(
        "--backup-dir", help="Directory to store backups (default: /var/backups/obsidianctl/slot_X)."
    )
    parser_backup.add_argument(
        "--device", help="Drive (not partition) to backup (default: current drive)."
    )
    parser_backup.add_argument("--full-backup", action="store_true", help="Backup your ENTIRE SYSTEM. (EXPERIMENTAL. USE AT YOUR OWN RISK.)")
    parser_backup.set_defaults(func=handle_backup_slot)
    
    parser_rollback = subparsers.add_parser(
        "rollback-slot", help="Rollback a slot to a previous backup."
    )
    parser_rollback.add_argument(
        "slot", choices=["a", "b"], help="The slot to rollback."
    )
    parser_rollback.add_argument(
        "backup_path", help="Path to the backup file (.sfs)."
    )
    parser_rollback.add_argument(
        "--device", help="Drive (not partition) to rollback (default: current drive)."
    )
    parser_rollback.set_defaults(func=handle_rollback_slot)
    
    parser_health = subparsers.add_parser(
        "health-check", help="Check the health of both A/B slots."
    )
    parser_health.set_defaults(func=handle_health_check)
    
    parser_verify = subparsers.add_parser(
        "verify-integrity", help="Verify the integrity of a specific slot."
    )
    parser_verify.add_argument(
        "slot", choices=["a", "b"], help="The slot to verify."
    )
    parser_verify.set_defaults(func=handle_verify_integrity)

    parser_update = subparsers.add_parser(
        "update", help="Update a slot with a new system image."
    )
    parser_update.add_argument(
        "slot", choices=["a", "b"], help="The slot to update."
    )
    parser_update.add_argument(
        "system_sfs", help="Path to the new SquashFS system image."
    )
    parser_update.add_argument(
        "--switch", action="store_true", help="Switch to the updated slot after updating."
    )
    parser_update.set_defaults(func=handle_update)

    parser_sync = subparsers.add_parser(
        "sync", help="Sync one slot to another."
    )
    parser_sync.add_argument(
        "slot", choices=["a", "b"], help="The slot to sync to."
    )
    parser_sync.set_defaults(func=handle_sync)

    parser_enter = subparsers.add_parser(
        "enter-slot", help="Chroot into a slot."
    )
    parser_enter.add_argument(
        "slot", choices=["a", "b"], help="The slot to chroot into."
    )
    parser_enter.add_argument(
        "--enable-networking", action="store_true", help="Enable networking in the chroot."
    )
    parser_enter.add_argument(
        "--mount-essentials", action="store_true", help="Mount /proc, /sys, and /dev."
    )
    parser_enter.add_argument(
        "--mount-home", action="store_true", help="Bind mount /home into the chroot."
    )
    parser_enter.add_argument(
        "--mount-root", action="store_true", help="Bind mount /root into the chroot."
    )
    parser_enter.set_defaults(func=handle_enter)
    parser_netupdate = subparsers.add_parser(
        "netupdate", help="Update a slot with the latest system image."
    )
    parser_netupdate.add_argument(
        "slot", choices=["a", "b"], help="The slot to update."
    )
    parser_netupdate.add_argument(
        "--break-system", action="store_true", help="Forcibly update even if not using an default system.sfs."
    )
    parser_netupdate.set_defaults(func=handle_netupdate)

    ext_parser = subparsers.add_parser("ext", help="Manage ObsidianOS extensions.")
    ext_subparsers = ext_parser.add_subparsers(dest="ext_command", required=True)

    ext_add_parser = ext_subparsers.add_parser("add", help="Add an ObsidianOS extension.")
    ext_add_parser.add_argument("path", help="Path to the .obsiext file.")
    ext_add_parser.set_defaults(func=handle_ext)

    ext_rm_parser = ext_subparsers.add_parser("rm", help="Remove an ObsidianOS extension.")
    ext_rm_parser.add_argument("name", help="Name of the extension to remove.")
    ext_rm_parser.set_defaults(func=handle_ext)

    ext_list_parser = ext_subparsers.add_parser("list", help="List installed ObsidianOS extensions.")
    ext_list_parser.set_defaults(func=handle_ext)

    ext_enable_parser = ext_subparsers.add_parser("enable", help="Enable ObsidianOS Overlays on boot.")
    ext_enable_parser.set_defaults(func=handle_ext)

    ext_disable_parser = ext_subparsers.add_parser("disable", help="Disable ObsidianOS Overlays on boot.")
    ext_disable_parser.set_defaults(func=handle_ext)

    parser_migrate = subparsers.add_parser(
        "migrate", help="Manage migration scripts."
    )
    migrate_subparsers = parser_migrate.add_subparsers(dest="migrate_command", required=True)

    # Migrate Run subcommand
    parser_migrate_run = migrate_subparsers.add_parser(
        "run", help="Run a migration script."
    )
    parser_migrate_run.add_argument(
        "id", help="The ID of the migration script to run."
    )
    parser_migrate_run.add_argument(
        "--repo",
        default="https://raw.githubusercontent.com/Obsidian-OS/migration/refs/heads/main/migration-{id}.sh",
        help="URL of the migration script repository. Use {id} as a placeholder for the migration ID.",
    )
    parser_migrate_run.add_argument(
        "--force", action="store_true", help="Force re-run migration even if already applied."
    )
    parser_migrate_run.set_defaults(func=handle_migrate)

    # Migrate Rollback subcommand
    parser_migrate_rollback = migrate_subparsers.add_parser(
        "rollback", help="Rollback a migration script."
    )
    parser_migrate_rollback.add_argument(
        "id", type=int, help="The ID of the migration script to rollback."
    )
    parser_migrate_rollback.add_argument(
        "--repo",
        default="https://raw.githubusercontent.com/Obsidian-OS/migration/refs/heads/main/migration-{id}.sh",
        help="URL of the migration script repository. Use {id} as a placeholder for the migration ID.",
    )
    parser_migrate_rollback.set_defaults(func=handle_rollback)

    # Migrate List subcommand
    parser_migrate_list = migrate_subparsers.add_parser(
        "list", help="List applied migrations."
    )
    parser_migrate_list.set_defaults(func=handle_list_migrations)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    args.func(args)

main()
